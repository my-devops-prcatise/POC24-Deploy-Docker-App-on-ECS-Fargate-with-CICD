name: CI/CD to ECS Fargate (ECR)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: poc24-node-app
  CONTAINER_NAME: webapp
  ECS_CLUSTER: poc24-cluster
  ECS_SERVICE: poc24-service
  TASK_DEF_FAMILY: poc24-task
  IMAGE_TAG: latest

jobs:
  build-and-deploy:
    runs-on: self-hosted
    # permissions:
    #   id-token: write
    #   contents: read

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      # Install Docker if missing (self-hosted convenience)
      - name: Install Docker Engine (Ubuntu)
        run: |
          if ! command -v docker >/dev/null 2>&1; then
            echo "Docker not found. Installing Docker Engine..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo systemctl enable --now docker
            sudo usermod -aG docker "$USER" || true
          else
            echo "Docker already installed: $(docker --version)"
          fi
          sudo docker version

      # Install AWS CLI v2 (self-hosted convenience)
      - name: Install AWS CLI v2
        run: |
          echo "Cleaning any previous AWS CLI..."
          sudo rm -rf aws /usr/local/aws-cli awscliv2.zip || true
          echo "Downloading AWS CLI v2..."
          curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          sudo apt-get update -y
          sudo apt-get install -y unzip
          unzip -o awscliv2.zip
          sudo ./aws/install
          aws --version

      # Configure AWS creds (you can switch to OIDC later)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          # For OIDC (recommended):
          # role-to-assume: arn:aws:iam::<ACCOUNT_ID>:role/GitHubOIDC-ECR-ECS

      # âœ… NEW: Create ECS cluster if it doesn't exist
      - name: Ensure ECS cluster exists
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          ECS_CLUSTER: ${{ env.ECS_CLUSTER }}
        run: |
          set -euo pipefail
          echo "Checking ECS cluster '$ECS_CLUSTER' in region '$AWS_REGION'..."
          if aws ecs describe-clusters --clusters "$ECS_CLUSTER" --region "$AWS_REGION" \
               --query 'failures[?reason==`MISSING`]' --output json | grep -q 'MISSING'; then
            echo "Cluster '$ECS_CLUSTER' not found. Creating..."
            aws ecs create-cluster --cluster-name "$ECS_CLUSTER" --region "$AWS_REGION"
            echo "Cluster '$ECS_CLUSTER' created."
          else
            echo "Cluster '$ECS_CLUSTER' exists."
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Ensure ECR repo exists (create if missing)
      - name: Ensure ECR repository exists
        env:
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail
          if aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "ECR repository '$ECR_REPOSITORY' already exists."
          else
            echo "Creating ECR repository '$ECR_REPOSITORY'..."
            aws ecr create-repository --repository-name "$ECR_REPOSITORY" \
              --image-scanning-configuration scanOnPush=true \
              --region "$AWS_REGION"
            echo "ECR repository '$ECR_REPOSITORY' created."
          fi

      # Because we use 'sudo docker ...', also log in ECR for root
      - name: Login ECR for root (for sudo docker)
        run: |
          aws ecr get-login-password --region "${{ env.AWS_REGION }}" \
          | sudo docker login --username AWS --password-stdin "${{ steps.login-ecr.outputs.registry }}"

      - name: Build, tag, and push image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          set -euo pipefail
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "Building $IMAGE_URI"
          # Optional: speed up if you want BuildKit caching etc.
          sudo docker build -t "$IMAGE_URI" .
          sudo docker push "$IMAGE_URI"
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

      # Optional: Ensure CloudWatch Logs group for awslogs driver
      - name: Ensure CloudWatch Logs group exists
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          LOG_GROUP: /ecs/${{ env.TASK_DEF_FAMILY }}
        run: |
          set -euo pipefail
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP" --region "$AWS_REGION" | grep -q "\"logGroupName\": \"$LOG_GROUP\""; then
            echo "Log group '$LOG_GROUP' already exists."
          else
            echo "Creating log group '$LOG_GROUP'..."
            aws logs create-log-group --log-group-name "$LOG_GROUP" --region "$AWS_REGION"
          fi

      - name: Render task definition with new image
        env:
          TASK_DEF_FAMILY: ${{ env.TASK_DEF_FAMILY }}
          AWS_REGION: ${{ env.AWS_REGION }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          ECS_EXECUTION_ROLE_ARN: ${{ secrets.ECS_EXECUTION_ROLE_ARN }}
          ECS_TASK_ROLE_ARN: ${{ secrets.ECS_TASK_ROLE_ARN }}
        run: |
          set -euo pipefail
          cat > taskdef.json <<EOF
          {
            "family": "${TASK_DEF_FAMILY}",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "${ECS_EXECUTION_ROLE_ARN}",
            "taskRoleArn": "${ECS_TASK_ROLE_ARN}",
            "containerDefinitions": [
              {
                "name": "${CONTAINER_NAME}",
                "image": "${IMAGE_URI}",
                "portMappings": [
                  { "containerPort": 3000, "protocol": "tcp" }
                ],
                "essential": true,
                "healthCheck": {
                  "command": ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"],
                  "interval": 30,
                  "timeout": 5,
                  "retries": 3,
                  "startPeriod": 10
                },
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/${TASK_DEF_FAMILY}",
                    "awslogs-region": "${AWS_REGION}",
                    "awslogs-stream-prefix": "ecs"
                  }
                },
                "environment": [
                  { "name": "PORT", "value": "3000" }
                ]
              }
            ]
          }
          EOF
          echo "taskdef.json rendered with IMAGE_URI=$IMAGE_URI"
          cat taskdef.json

      # Optional: fail fast if service is missing/misconfigured
      - name: Validate ECS service exists
        run: |
          set -euo pipefail
          if ! aws ecs describe-services --cluster "${{ env.ECS_CLUSTER }}" --services "${{ env.ECS_SERVICE }}" --region "${{ env.AWS_REGION }}" \
            --query 'services[?serviceName==`'${{ env.ECS_SERVICE }}'` && status==`ACTIVE`].serviceName' --output text | grep -q "${{ env.ECS_SERVICE }}"; then
            echo "ERROR: ECS service '${{ env.ECS_SERVICE }}' not found or not ACTIVE on cluster '${{ env.ECS_CLUSTER }}'."
            echo "Tip: Create the service once via Console/Terraform with VPC subnets/SG/target group, then rerun this workflow."
            exit 1
          fi
          echo "ECS service validated."

      - name: Deploy to Amazon ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: taskdef.json
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
